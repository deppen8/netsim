import geopandas as gpd
import numpy as np
import netsim.utils as utils
import netsim.path_tools as ptools
from netsim.cost import calculate_dt, calculate_iwdt

from pathlib import Path
data_path = Path.cwd().parent / "netsim" / "data"

fn_dem = data_path / "sample" / "sampleDEM.tif"

dem, profile = utils.read_raster(fn_dem)

cellsize = profile['transform'].a

fn_shp = data_path / "sample" / "sample5.shp"

df_temp = gpd.read_file(fn_shp)

# make a copy
df = df_temp.copy(deep=True)
df['r'], df['c'] = utils.pt2rc(df['geometry'], profile)

vftfn = data_path / "iwdt" / "grad2cost.csv"
vft = np.genfromtxt(vftfn, delimiter=',')

coef = np.polyfit(np.tan(np.radians(vft[: , 0])), vft[:,1], deg=4)

iwdt = np.full_like(dem, 999999.0)

# retrieve the row and column of point 0
sel = df['id'] == 0
row_0 = df.loc[sel, 'r'].values[0]
col_0 = df.loc[sel, 'c'].values[0]

# set to 0.9
iwdt[row_0, col_0]= 0.0

cost_dict={
    'dem': dem,
    'netcost': np.zeros_like(dem), # no previous netcost
    'cellsize': cellsize,
    'weight': 0.0,                 # it does not matter what we put here as netcost is made out of 0s
    'coef': coef
}

def test_iwdt_runs():
    calculate_iwdt(iwdt, cost_dict)
    assert True


# # %%
# utils.plot_map(raster = {'ras':iwdt, 'profile':profile},
#                loc={'df':df, 'label':'id'},
#                cmap='magma',
#                title= 'IWDT from point 0',
#                cbar = True)

# # %% [markdown]
# # ##### *find path connecting 0 to 2*

# # %%
# # retrieve the row and column of point 2
# sel = df['id'] == 2
# row_2 = df.loc[sel, 'r'].values[0]
# col_2 = df.loc[sel, 'c'].values[0]


# # %%
# origin = [row_0, col_0]
# dest = [row_2, col_2]
# path0_2, _ = ptools.create_paths(blx, bly, [origin], [dest])


# # %%
# utils.plot_map(raster= {'ras':dem, 'profile':profile, 'paths': path0_2},
#                loc={'df':df, 'label':'id'},
#                cmap='Purples')

# # %% [markdown]
# # ## Exploring path influence
# # 
# # While `calculate_iwdt()` can generate similar paths as generated by other GIS, the true advantage of using `calculate_iwdt()` is the possibility of incorporating an *influence weighted* layer that we can use when calculating additional paths. You should think of this *influence weighted* layer as the inverse of a cost layer. The higher the influence the less the cost and vice versa. In this particular case, we are going to generate our *influence (cost) weighted* layer from the path we just generated so that its influence is maximum (i.e. cost is minimum) while on the path and declines (or increases for the cost) exponentially with distance. 
# # 
# # ##### *generating influence layer*
# # 
# # Here, we shall consider that at a distance of $d$= 0m the cost of the path is minimum while at a distance of $d$=25m its cost has exponentially increased to $\frac{1}{4} $. To do this we use the following formulae,
# # 
# #  $$ PathCost= 1 - e^{d/\alpha} $$
# # 
# # Where,
# # - $d$ distance from path
# # - $\alpha$ is a factor calculated using the following formula,
# # $$ \alpha = \frac {d_0} {ln(1 - NC_0)} $$   
# # 
# # In order to calculate such a layer, we first need to generate a layer that calculates distance away from the path. We do this using the `calculate_dt()` function.
# # 
# # ##### *initialize a layer to 99999.0 and set path location to 0.0*

# # %%
# d = np.full_like(dem, 99999.0)
# d[path0_2 >= 1.0] = 0.0

# # %% [markdown]
# # ##### *calculate distance away*

# # %%
# d = calculate_dt(d, cost_dict['cellsize'], option=2)


# # %%
# utils.plot_map(raster= {'ras':d, 'profile':profile},
#                cmap='magma',
#                title= 'distance away from path',
#                cbar= True)

# # %% [markdown]
# # ##### *calculate the influence (cost) associated with the path*

# # %%
# from math import log

# d0 = 25 # distance @ which 
# NC0 = 0.25  # cost is only beta
# alpha = d0 / log(1- NC0)

# # path influence layer
# pathcost = 1.0 - np.exp(d / alpha)


# # %%
# utils.plot_map(raster= {'ras':pathcost, 'profile':profile},
#                cmap='magma',
#                title= 'path influence (cost)',
#                cbar = True)

# # %% [markdown]
# # ### Generate a second path with varying weight
# # 
# # Now that we have generated a layer that describes the influence of the path from 0 to 2, we are going to generate a second path from 1 to 2. For this however, we are going to be varying the weight associated with our first path.
# # %% [markdown]
# # ##### *calculate path connecting 1 to 2*

# # %%
# # retrieve the row and column of point 1
# sel = df['id'] == 1
# row_1 = df.loc[sel, 'r'].values[0]
# col_1 = df.loc[sel, 'c'].values[0]

# # new origin
# origin = [row_1, col_1]

# # %% [markdown]
# # #### Loop through weights

# # %%
# ws = [0, 0.1, 0.2, 0.3, 0.5, 0.7, 0.9]


# # %%
# # set netcost
# cost_dict['netcost'] = pathcost

# for w in ws:
#     # Change weight
#     cost_dict['weight'] = w
    
#     # initialize iwdt
#     iwdt = np.full_like(dem, 999999.0)
#     iwdt[origin[0], origin[1]] = 0.0
    
#     # run iwdt
#     iwdt, blx, bly = calculate_iwdt(iwdt, cost_dict)
    
#     # find path
#     path, _ = ptools.create_paths(blx, bly, [origin], [dest])
    
#     # printout results
#     utils.plot_map({'ras':dem, 'profile':profile, 'paths':path},
#                    loc={'df':df, 'label':'id'}, 
#                    cmap='Purples',
#                    title= 'weight= '+ str(w) )
